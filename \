import datetime

from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from django.utils.translation import ugettext_lazy as _


from bricks.utils import inheritors
from bricks.managers import PublicationManager

import django.db.models.options as options

options.DEFAULT_NAMES = options.DEFAULT_NAMES + ('template_name_field', 'template_name_suffix')


class PublicationAbstract(models.Model):
    is_active = models.BooleanField(
        default=False,
        verbose_name=_('is active'))
    add_date = models.DateTimeField(
        auto_now_add=True,
        blank=True,
        editable=False,
        null=True,
        verbose_name=_('creation date'))
    mod_date = models.DateTimeField(
        auto_now=True,
        blank=True,
        editable=False,
        null=True,
        verbose_name=_("last modification date"))
    pub_date = models.DateTimeField(
        default=datetime.datetime.now,
        verbose_name=_("publication date"),
        help_text=_("For an entry to be published, it must be active and its publication date must be in the past."))
    end_date = models.DateTimeField(
        blank=True,
        null=True,
        verbose_name=_("publication end date"))

    objects = PublicationManager()

    class Meta:
        abstract = True
        ordering = ('-pub_date',)
        get_latest_by = 'pub_date'


class Page(PublicationAbstract):
    title = models.CharField(
        max_length=256,
        verbose_name=_(u"title"))

    slug = models.SlugField(
        verbose_name=_(u"slug"))

    description = models.CharField(
        blank=True,
        max_length=1024,
        null=True,
        verbose_name=_(u"description"))

    content_type = models.ForeignKey(
        to=ContentType,
        blank=True,
        null=True,
        #limit_choices_to=tie_content_type_choices_limit()
    )
    object_id = models.PositiveIntegerField(
        blank=True,
        null=True)
    content_object = generic.GenericForeignKey('content_type', 'object_id')


TEMPLATE_NAME_FIELD = None
TEMPLATE_NAME_SUFFIX = '_detail'


class Brick(PublicationAbstract):
    title = models.CharField(
        max_length=256,
        verbose_name=_(u"title"))

    slug = models.SlugField(
        verbose_name=_(u"slug"))

    description = models.CharField(
        blank=True,
        max_length=1024,
        null=True,
        verbose_name=_(u"description"))

    class Meta(PublicationAbstract.Meta):
        verbose_name = _(u"tie")
        verbose_name_plural = _(u"ties")
        unique_together = (('content_type', 'object_id'), ('slug', 'level'))
        template_name_field = TEMPLATE_NAME_FIELD

    def __unicode__(self):
        return self.title
"""
    def get_absolute_url(self):
        path = '/'
        for p in self.get_ancestors(include_self=True, ascending=False):
            path += p.slug + '/'
        return path

    def get_template_names(self, path):
        names = []
        template_name_suffix = getattr(self._meta, 'template_name_suffix', TEMPLATE_NAME_SUFFIX)
        template_name_field = getattr(self._meta, 'template_name_field', TEMPLATE_NAME_FIELD)
        if template_name_field:
            name = getattr(self.object, template_name_field, None)
            if name:
                names.append(name)
        else:
            tail = "%s_%s%s.html" % (
                self._meta.app_label,
                self._meta.object_name.lower(),
                template_name_suffix,
            )
            path_elements = path.split('/')
            for i, slug in enumerate(path_elements):
                p = '/'.join(path_elements[:len(path_elements) - i])
                names.append("bricks/ties/%s/%s" % (p, tail,))
            names.append("bricks/ties/%s" % (tail,))
            for i, slug in enumerate(path_elements):
                p = '/'.join(path_elements[:len(path_elements) - i])
                names.append("bricks/ties/%s/tie%s.html" % (p, template_name_suffix))
            names.append("bricks/ties/tie_detail.html")

        return names
        template_name_suffix = TEMPLATE_NAME_SUFFIX
"""
"""
def tie_content_type_choices_limit():
    def _wrapped():
        models = inheritors(TiedObject)
        return [c.pk for m, c in ContentType.objects.get_for_models(*models).items()]
    return {'id__in': _wrapped}


def tie_default_parent():
    def _wrapped():
        try:
            return Tie.objects.get(level=0)
        except Tie.DoesNotExist:
            return None
    return _wrapped
"""
